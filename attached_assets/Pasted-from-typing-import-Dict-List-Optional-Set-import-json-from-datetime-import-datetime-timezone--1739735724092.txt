from typing import Dict, List, Optional, Set
import json
from datetime import datetime, timezone
import psycopg2
from psycopg2.extras import Json
import os

class TaxonomyCache:
    def __init__(self):
        self.conn = psycopg2.connect(os.environ["DATABASE_URL"])
        self._ensure_tables()

    def _ensure_tables(self):
        """Ensure all required tables and indices exist."""
        with self.conn.cursor() as cur:
            cur.execute("""
                DO $$ 
                BEGIN
                    CREATE TABLE IF NOT EXISTS taxonomy_structure (
                        root_id INTEGER PRIMARY KEY,
                        complete_subtree JSONB NOT NULL,
                        species_count INTEGER NOT NULL,
                        last_updated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                        confidence_complete BOOLEAN DEFAULT FALSE,
                        ancestor_chain INTEGER[] NOT NULL DEFAULT '{}'
                    );

                    CREATE TABLE IF NOT EXISTS filtered_trees (
                        cache_key TEXT PRIMARY KEY,
                        filtered_tree JSONB NOT NULL,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                    );
                END $$;

                CREATE INDEX IF NOT EXISTS taxonomy_ancestor_chain_idx 
                ON taxonomy_structure USING GIN(ancestor_chain);

                CREATE INDEX IF NOT EXISTS taxonomy_subtree_idx 
                ON taxonomy_structure USING GIN(complete_subtree jsonb_path_ops);

                CREATE INDEX IF NOT EXISTS filtered_trees_created_idx 
                ON filtered_trees(created_at);
            """)
            self.conn.commit()

    def get_cached_tree(self, root_id: int, max_age_days: int = 30) -> Optional[Dict]:
        """Retrieve a cached taxonomy tree with age validation."""
        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT 
                    complete_subtree,
                    last_updated,
                    confidence_complete,
                    species_count,
                    ancestor_chain
                FROM taxonomy_structure
                WHERE root_id = %s
                AND last_updated > NOW() - INTERVAL '%s days'
            """, (root_id, max_age_days))

            result = cur.fetchone()
            if result and result[2]:  # Check confidence_complete flag
                return {
                    'tree': result[0],
                    'ancestor_chain': result[4] or []
                }
        return None

    def build_tree_from_taxa(self, root_id: int, species_ids: List[int]) -> Dict:
        """Build complete taxonomy tree from taxa table."""
        print(f"Building tree for root {root_id} with {len(species_ids)} species")
        
        tree = {}
        all_taxa = set()
        
        # First, get all species data
        with self.conn.cursor() as cur:
            placeholders = ','.join(['%s'] * len(species_ids))
            cur.execute(f"""
                SELECT 
                    taxon_id,
                    name,
                    rank,
                    common_name,
                    ancestor_ids,
                    ancestor_data
                FROM taxa
                WHERE taxon_id IN ({placeholders})
            """, species_ids)
            
            species_data = cur.fetchall()
            print(f"Found {len(species_data)} species records")

        # Process each species and its ancestors
        for species in species_data:
            species_id, name, rank, common_name, ancestor_ids, ancestor_data = species
            
            # Add species to all_taxa set
            all_taxa.add(species_id)
            all_taxa.update(ancestor_ids or [])
            
            # Build branch from root to species
            current_dict = tree
            for ancestor_id in ancestor_ids or []:
                if ancestor_id not in current_dict:
                    # Get ancestor data
                    with self.conn.cursor() as cur:
                        cur.execute("""
                            SELECT name, rank, common_name
                            FROM taxa
                            WHERE taxon_id = %s
                        """, (ancestor_id,))
                        ancestor = cur.fetchone()
                        if ancestor:
                            current_dict[ancestor_id] = {
                                'id': ancestor_id,
                                'name': ancestor[0],
                                'rank': ancestor[1],
                                'common_name': ancestor[2],
                                'children': {}
                            }
                current_dict = current_dict[ancestor_id]['children']
            
            # Add species node
            current_dict[species_id] = {
                'id': species_id,
                'name': name,
                'rank': rank,
                'common_name': common_name,
                'children': {}
            }

        print(f"Built tree with {len(all_taxa)} total taxa")
        return tree

    def save_tree(self, root_id: int, tree: Dict, species_ids: List[int]):
        """Save a complete taxonomy tree with ancestor chains."""
        print(f"Saving tree for root {root_id}")
        print(f"Tree structure: {json.dumps(tree, indent=2)}")
        
        # Get all ancestor chains
        all_chains = set()
        for species_id in species_ids:
            with self.conn.cursor() as cur:
                cur.execute("""
                    SELECT ancestor_ids
                    FROM taxa
                    WHERE taxon_id = %s
                """, (species_id,))
                result = cur.fetchone()
                if result and result[0]:
                    all_chains.update(result[0])
                all_chains.add(species_id)

        print(f"Found {len(all_chains)} total ancestors")

        with self.conn as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    INSERT INTO taxonomy_structure 
                    (root_id, complete_subtree, species_count, last_updated, 
                     confidence_complete, ancestor_chain)
                    VALUES (%s, %s, %s, %s, %s, %s)
                    ON CONFLICT (root_id) DO UPDATE
                    SET complete_subtree = EXCLUDED.complete_subtree,
                        species_count = EXCLUDED.species_count,
                        last_updated = EXCLUDED.last_updated,
                        confidence_complete = EXCLUDED.confidence_complete,
                        ancestor_chain = EXCLUDED.ancestor_chain
                """, (
                    root_id,
                    Json(tree),
                    len(species_ids),
                    datetime.now(timezone.utc),
                    True,
                    list(all_chains)
                ))

    def get_filtered_user_tree(self, root_id: int, user_species_ids: List[int]) -> Optional[Dict]:
        """Get a filtered tree for user species."""
        print(f"Getting filtered tree for root {root_id} and {len(user_species_ids)} species")
        
        cache_key = f"{root_id}_{sorted(user_species_ids)}"

        # Check filtered trees cache
        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT filtered_tree
                FROM filtered_trees
                WHERE cache_key = %s
                AND created_at > NOW() - INTERVAL '1 day'
            """, (cache_key,))
            
            cached = cur.fetchone()
            if cached:
                print("Found cached filtered tree")
                return cached[0]

        # Get complete tree
        complete_data = self.get_cached_tree(root_id)
        if not complete_data:
            print("No complete tree found, building new one")
            tree = self.build_tree_from_taxa(root_id, user_species_ids)
            if not tree:
                return None
        else:
            print("Found complete tree in cache")
            tree = complete_data['tree']

        # Filter tree
        filtered_tree = self._filter_tree_efficient(tree, set(user_species_ids))
        
        if filtered_tree:
            print("Saving filtered tree to cache")
            with self.conn as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        INSERT INTO filtered_trees (cache_key, filtered_tree)
                        VALUES (%s, %s)
                        ON CONFLICT (cache_key) 
                        DO UPDATE SET filtered_tree = EXCLUDED.filtered_tree,
                                    created_at = CURRENT_TIMESTAMP
                    """, (cache_key, Json(filtered_tree)))

        return filtered_tree

    def _filter_tree_efficient(self, complete_tree: Dict, keep_species: Set[int]) -> Optional[Dict]:
        """Filter tree to only include paths to specified species."""
        print(f"Filtering tree for {len(keep_species)} species")
        
        valid_paths = set()

        def find_valid_paths(node: Dict, current_path: List[int]):
            node_id = node.get('id')
            if not node_id:
                return

            current_path.append(node_id)

            if node.get('rank') == 'species' and node_id in keep_species:
                valid_paths.update(current_path)

            for child in node.get('children', {}).values():
                find_valid_paths(child, current_path.copy())

        find_valid_paths(complete_tree, [])
        print(f"Found {len(valid_paths)} valid taxa in paths")

        def prune_tree(node: Dict) -> Optional[Dict]:
            node_id = node.get('id')
            if not node_id or node_id not in valid_paths:
                return None

            pruned_children = {}
            for child_id, child in node.get('children', {}).items():
                pruned_child = prune_tree(child)
                if pruned_child:
                    pruned_children[child_id] = pruned_child

            if pruned_children or node.get('rank') == 'species':
                filtered_node = node.copy()
                filtered_node['children'] = pruned_children
                return filtered_node

            return None

        filtered = prune_tree(complete_tree)
        print(f"Filtered tree created: {json.dumps(filtered, indent=2)}")
        return filtered